<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lottery EV Calculator v2 Enhanced</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useMemo, useState } = React;

    // ---- RNG helpers for Monte Carlo ----
    function randn() {
      let u = 0, v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }
    function normalSample(mean, std) { return mean + std * randn(); }
    function poissonSample(lambda) {
      if (lambda <= 0) return 0;
      if (lambda < 30) {
        const L = Math.exp(-lambda); let k = 0, p = 1;
        do { k++; p *= Math.random(); } while (p > L);
        return k - 1;
      } else {
        const val = Math.round(normalSample(lambda, Math.sqrt(lambda)));
        return Math.max(0, val);
      }
    }
    function binomialSample(n, p) {
      if (n <= 0 || p <= 0) return 0;
      if (p >= 1) return n;
      const mean = n * p;
      if (mean < 30) {
        const val = poissonSample(mean);
        return Math.min(n, val);
      } else {
        const val = Math.round(normalSample(mean, Math.sqrt(n * p * (1 - p))));
        return Math.min(n, Math.max(0, val));
      }
    }
    // Approx hyperg√©om√©trique (assez pr√©cis ici)
    function hypergeomSample(N, K, n) {
      if (N <= 0 || K <= 0 || n <= 0) return 0;
      return binomialSample(n, K / N);
    }

// Lottery EV Calculator ‚Äì single-file React app v2 Enhanced
// - TailwindCSS for styling
// - No external deps
// - Supports 1 bonus pool (with B bonus draws) and arbitrary prize ranks (exact or range constraints)
// - EV formula (pari-mutuel, fixed purses shared among winners):
//   EV(N) = [Œ£_r Purse_r * (1 - (1 - p_r)^N)] / N  (+ optional weekly airdrop per-ticket)
// - p_r = P(exactly k main matches AND s bonus matches) with hypergeometric draws
// - Includes: expected winners per rank, per-ticket probabilities, rank contributions, break-even solver, airdrop
// - NEW: Data feeds, BNB mode, "My tickets" section, presets, EV0 breakdown

// ---------- helpers ----------
function clamp(n, lo, hi) { return Math.max(lo, Math.min(hi, n)); }
function fmt(n, d = 2) { return isFinite(n) ? n.toLocaleString(undefined, { maximumFractionDigits: d, minimumFractionDigits: d }) : "‚Äì"; }
function fmt0(n) { return isFinite(n) ? n.toLocaleString() : "‚Äì"; }

function choose(n, k) {
  if (k < 0 || k > n) return 0;
  k = Math.min(k, n - k);
  let num = 1, den = 1;
  for (let i = 1; i <= k; i++) {
    num *= (n - (k - i));
    den *= i;
  }
  return num / den;
}

// Hypergeometric probability: drawing drawCount items without replacement from poolSize,
// probability of exactly m matches when you have picked pickCount target items
function hypergeomExact(poolSize, pickCount, drawCount, m) {
  // P = [C(pickCount, m) * C(poolSize - pickCount, drawCount - m)] / C(poolSize, drawCount)
  if (m < 0 || m > pickCount || m > drawCount) return 0;
  const top = choose(pickCount, m) * choose(poolSize - pickCount, drawCount - m);
  const bottom = choose(poolSize, drawCount);
  return bottom > 0 ? top / bottom : 0;
}

function sumRange(lo, hi, f) {
  let s = 0;
  for (let i = lo; i <= hi; i++) s += f(i);
  return s;
}

// dot-path extractor for JSON feeds (e.g., "data.price.usd")
function getByPath(obj, path) {
  if (!path) return obj;
  return String(path).split('.').reduce((acc, key) => (acc && typeof acc === 'object') ? acc[key] : undefined, obj);
}

// ---------- default model (Euromillions-like variant the user asked for) ----------
const defaultModel = {
  ticketPrice: 0.0813392,
  totalTickets: 143088,
  main: { poolSize: 50, drawCount: 5 },
  bonus: { poolSize: 9, drawCount: 1 }, // can set drawCount > 1 if more than one bonus is drawn
  weeklyAirdrop: { enabled: true, tokenAmount: 5_000_000, tokenUsdPrice: 0.0995, weeklyTickets: 143088 },
  // Ranks: each row defines constraints and a fixed purse (USD) to be shared among winners
  // mode: "exact" means exactly X; "range" means min..max inclusive
  ranks: [
    { id: "5+1", name: "5 + 1 bonus", mainMode: "exact", mainExact: 5, bonusMode: "exact", bonusExact: 1, purseUsd: 106290.75, enabled: true },
    { id: "5+0", name: "5 + 0 bonus", mainMode: "exact", mainExact: 5, bonusMode: "exact", bonusExact: 0, purseUsd: 10629.08, enabled: true },
    { id: "4+1", name: "4 + 1 bonus", mainMode: "exact", mainExact: 4, bonusMode: "exact", bonusExact: 1, purseUsd: 5314.54, enabled: true },
    { id: "4+0", name: "4 + 0 bonus", mainMode: "exact", mainExact: 4, bonusMode: "exact", bonusExact: 0, purseUsd: 7086.05, enabled: true },
    { id: "3+1", name: "3 + 1 bonus", mainMode: "exact", mainExact: 3, bonusMode: "exact", bonusExact: 1, purseUsd: 10629.08, enabled: true },
    { id: "3+0", name: "3 + 0 bonus", mainMode: "exact", mainExact: 3, bonusMode: "exact", bonusExact: 0, purseUsd: 15943.61, enabled: true },
    { id: "2+1", name: "2 + 1 bonus", mainMode: "exact", mainExact: 2, bonusMode: "exact", bonusExact: 1, purseUsd: 21258.15, enabled: true },
  ],
};

function useLottery(model) {
  const {
    ticketPrice,
    totalTickets: N,
    main: { poolSize: nMain, drawCount: mMain },
    bonus: { poolSize: nBonus, drawCount: mBonus },
    weeklyAirdrop,
    ranks,
  } = model;

  // per-rank probability p_r and expected winners
  const perRankAll = useMemo(() => {
    return ranks.map(r => {
      const pMain = r.mainMode === "exact"
        ? hypergeomExact(nMain, mMain, mMain, r.mainExact)
        : sumRange(r.mainMin ?? 0, r.mainMax ?? mMain, (k) => hypergeomExact(nMain, mMain, mMain, k));

      const pBonus = mBonus > 0
        ? (r.bonusMode === "exact"
            ? hypergeomExact(nBonus, mBonus, mBonus, r.bonusExact)
            : sumRange(r.bonusMin ?? 0, r.bonusMax ?? mBonus, (s) => hypergeomExact(nBonus, mBonus, mBonus, s)))
        : (r.bonusMode === "exact" ? (r.bonusExact === 0 ? 1 : 0) : 1);

      const p = pMain * pBonus;
      const expectedWinners = N * p;
      const probAtLeastOneWinner = 1 - Math.pow(1 - p, N);
      const contributionPerTicket = (r.purseUsd * probAtLeastOneWinner) / N;
      return { r, p, expectedWinners, probAtLeastOneWinner, contributionPerTicket };
    });
  }, [ranks, N, nMain, mMain, nBonus, mBonus]);

  const perRank = useMemo(() => perRankAll.filter(x => x.r.enabled), [perRankAll]);

  const evPurses = useMemo(() => perRank.reduce((s, x) => s + x.contributionPerTicket, 0), [perRank]);

  const evAirdropPerTicket = useMemo(() => {
    if (!weeklyAirdrop?.enabled) return 0;
    const tokens = Math.max(0, Number(weeklyAirdrop.tokenAmount) || 0);
    const price = Math.max(0, Number(weeklyAirdrop.tokenUsdPrice) || 0);
    const total = tokens * price; // USD airdropped this week
    const denom = Math.max(1, Number(weeklyAirdrop.weeklyTickets) || N);
    return total / denom;
  }, [weeklyAirdrop, N]);

  const evPerTicket = evPurses + evAirdropPerTicket;
  const evNetPerTicket = evPerTicket - ticketPrice;
  const roi = evPerTicket / ticketPrice;

  // Solve for break-even N* (ignoring airdrop or optionally include)
  function breakEven(includeAirdrop) {
    const maxN = 5_000_000; // search bound
    const minN = 1;
    function evAt(Nx) {
      // recompute contributions at Nx (keeping per-rank p same because p depends on structure, not N)
      let s = 0;
      for (const x of perRank) {
        const p = x.p;
        const prob = 1 - Math.pow(1 - p, Nx);
        s += (x.r.purseUsd * prob) / Nx;
      }
      if (includeAirdrop) {
        const tokens = Math.max(0, Number(weeklyAirdrop.tokenAmount) || 0);
        const price = Math.max(0, Number(weeklyAirdrop.tokenUsdPrice) || 0);
        const total = tokens * price;
        const denom = Math.max(1, Number(weeklyAirdrop.weeklyTickets) || Nx);
        s += total / denom;
      }
      return s;
    }
    if (evAt(maxN) > model.ticketPrice) return null; // still EV+ within bounds
    let lo = minN, hi = maxN;
    while (hi - lo > 1) {
      const mid = Math.floor((lo + hi) / 2);
      const e = evAt(mid);
      if (e > model.ticketPrice) lo = mid; else hi = mid;
    }
    return hi;
  }

  const nStarNoAirdrop = useMemo(() => breakEven(false), [perRank, weeklyAirdrop, model.ticketPrice]);
  const nStarWithAirdrop = useMemo(() => breakEven(true), [perRank, weeklyAirdrop, model.ticketPrice]);

  return { perRank, perRankAll, evPurses, evAirdropPerTicket, evPerTicket, evNetPerTicket, roi, nStarNoAirdrop, nStarWithAirdrop };
}

function NumberInput({ label, value, onChange, step = 1, min = 0, className = "" }) {
  return (
    <label className={`flex flex-col gap-1 ${className}`}>
      <span className="text-xs text-slate-400">{label}</span>
      <input type="number" step={step} min={min} value={value}
        onChange={e => onChange(Number(e.target.value))}
        className="px-3 py-2 rounded-xl bg-slate-800/60 border border-slate-700 text-slate-100 focus:outline-none" />
    </label>
  );
}

function TextInput({ label, value, onChange, placeholder = "", className = "" }) {
  return (
    <label className={`flex flex-col gap-1 ${className}`}>
      <span className="text-xs text-slate-400">{label}</span>
      <input type="text" value={value} placeholder={placeholder}
        onChange={e => onChange(e.target.value)}
        className="px-3 py-2 rounded-xl bg-slate-800/60 border border-slate-700 text-slate-100 focus:outline-none" />
    </label>
  );
}

function Switch({ label, checked, onChange }) {
  return (
    <div className="flex items-center gap-3">
      <button onClick={() => onChange(!checked)}
        className={`w-12 h-7 rounded-full p-1 transition ${checked ? "bg-emerald-500/80" : "bg-slate-600"}`}>
        <div className={`h-5 w-5 rounded-full bg-white transition ${checked ? "translate-x-5" : "translate-x-0"}`} />
      </button>
      <span className="text-sm text-slate-300">{label}</span>
    </div>
  );
}

function RankRow({ r, mMain, mBonus, onChange, onRemove }) {
  const update = (patch) => onChange({ ...r, ...patch });
  return (
    <div className="grid grid-cols-12 gap-2 items-end p-3 rounded-2xl bg-slate-900/60 border border-slate-800">
      <input className="col-span-2 px-3 py-2 rounded-xl bg-slate-800/60 border border-slate-700 text-slate-100"
             value={r.name} onChange={e => update({ name: e.target.value })} />

      <div className="col-span-3 grid grid-cols-3 gap-2">
        <select value={r.mainMode} onChange={e => update({ mainMode: e.target.value })}
          className="col-span-1 px-2 py-2 rounded-xl bg-slate-800/60 border border-slate-700 text-slate-100">
          <option value="exact">main =</option>
          <option value="range">main min..max</option>
        </select>
        {r.mainMode === "exact" ? (
          <NumberInput className="col-span-2" label={`Main (0..${mMain})`} value={r.mainExact}
            onChange={v => update({ mainExact: clamp(v, 0, mMain) })} />
        ) : (
          <>
            <NumberInput label={`Main min`} value={r.mainMin ?? 0} onChange={v => update({ mainMin: clamp(v, 0, mMain) })} />
            <NumberInput label={`Main max`} value={r.mainMax ?? mMain} onChange={v => update({ mainMax: clamp(v, 0, mMain) })} />
          </>
        )}
      </div>

      <div className="col-span-3 grid grid-cols-3 gap-2">
        <select value={r.bonusMode} onChange={e => update({ bonusMode: e.target.value })}
          className="col-span-1 px-2 py-2 rounded-xl bg-slate-800/60 border border-slate-700 text-slate-100">
          <option value="exact">bonus =</option>
          <option value="range">bonus min..max</option>
        </select>
        {r.bonusMode === "exact" ? (
          <NumberInput className="col-span-2" label={`Bonus (0..${mBonus})`} value={r.bonusExact}
            onChange={v => update({ bonusExact: clamp(v, 0, mBonus) })} />
        ) : (
          <>
            <NumberInput label={`Bonus min`} value={r.bonusMin ?? 0} onChange={v => update({ bonusMin: clamp(v, 0, mBonus) })} />
            <NumberInput label={`Bonus max`} value={r.bonusMax ?? mBonus} onChange={v => update({ bonusMax: clamp(v, 0, mBonus) })} />
          </>
        )}
      </div>

      <NumberInput className="col-span-2" label="Purse (USD)" value={r.purseUsd}
        onChange={v => update({ purseUsd: Math.max(0, v) })} step={0.01} />

      <div className="col-span-1 flex items-center justify-center">
        <Switch label="" checked={r.enabled} onChange={(c) => update({ enabled: c })} />
      </div>

      <div className="col-span-1 flex justify-end">
        <button className="px-3 py-2 rounded-xl bg-rose-700/70 hover:bg-rose-700 text-white" onClick={onRemove}>‚úï</button>
      </div>
    </div>
  );
}

function LotteryEVApp() {
  const [model, setModel] = useState(defaultModel);
  // Pricing mode: USD or BNB ‚Üí we always compute an effective USD price for EV math
  const [priceMode, setPriceMode] = useState('USD');
  const [ticketPriceBNB, setTicketPriceBNB] = useState(0.0000888);
  const [bnbUsd, setBnbUsd] = useState(948.4); // default from CoinGecko snapshot; editable in UI
  const [myTickets, setMyTickets] = useState(100);
  const [tab, setTab] = useState('PARAM'); // 'PARAM' | 'STATS' | 'SIM'

  // Monte Carlo sim state
  const [simTrials, setSimTrials]   = useState(10000);
  const [simResults, setSimResults] = useState(null);
  const [simRunning, setSimRunning] = useState(false);

  // ---- Data feeds (URLs, JSON paths, last fetched values) ----
  const [feed, setFeed] = useState({
    bnb:   { url: "", path: "", last: null, error: null },
    lucky: { url: "", path: "", last: null, error: null },
    tokens:{ url: "", path: "", last: null, error: null },
    weekly:{ url: "", path: "", last: null, error: null },
    model: { url: "" }
  });
  function updateFeedField(key, patch) {
    setFeed(f => ({ ...f, [key]: { ...f[key], ...patch } }));
  }
  async function fetchApplyNumber(key, apply) {
    try {
      if (!feed[key].url) return updateFeedField(key, { error: "URL manquante" });
      const res = await fetch(feed[key].url);
      const json = await res.json();
      const val = getByPath(json, feed[key].path);
      if (typeof val === 'number' && isFinite(val)) {
        apply(val);
        updateFeedField(key, { last: val, error: null });
      } else {
        updateFeedField(key, { error: "La cl√© ne pointe pas vers un nombre", last: null });
      }
    } catch (e) {
      updateFeedField(key, { error: String(e), last: null });
    }
  }
  async function loadModelFromUrl() {
    try {
      if (!feed.model.url) return;
      const res = await fetch(feed.model.url);
      const json = await res.json();
      setModel(json);
    } catch (e) {
      alert("√âchec du chargement: " + String(e));
    }
  }

  // Compute effective ticket price in USD depending on mode
  const effectiveTicketPrice = priceMode === 'USD' ? model.ticketPrice : (ticketPriceBNB * bnbUsd);
  const derivedModel = { ...model, ticketPrice: effectiveTicketPrice };
  const { perRank, perRankAll, evPurses, evAirdropPerTicket, evPerTicket, evNetPerTicket, roi, nStarNoAirdrop, nStarWithAirdrop } = useLottery(derivedModel);

  // Break-even (airdrop-only): weeklyTickets* such that airdrop per ticket == ticket price
  const airdropBreakEvenWeeklyTickets = React.useMemo(() => {
    const tokens = Math.max(0, model.weeklyAirdrop?.tokenAmount || 0);
    const tokenUsd = Math.max(0, model.weeklyAirdrop?.tokenUsdPrice || 0);
    const totalUsd = tokens * tokenUsd;
    const priceT = derivedModel.ticketPrice;
    if (totalUsd <= 0 || priceT <= 0) return null;
    return Math.ceil(totalUsd / priceT);
  }, [model.weeklyAirdrop, derivedModel.ticketPrice]);

  const airdropCoverage = derivedModel.ticketPrice > 0 ? (evAirdropPerTicket / derivedModel.ticketPrice) : 0;

  // My tickets summary (what I get if I buy X tickets)
  const myPursesUsd = myTickets * evPurses;
  const myAirdropUsd = myTickets * evAirdropPerTicket;
  const myEV = myTickets * evPerTicket;
  const myCost = myTickets * effectiveTicketPrice;
  const myNet = myEV - myCost;
  const myROI = myEV / myCost;

  // Scenario computations: impact of excluding top ranks for myTickets
  const baseKeepIds = useMemo(() => model.ranks.filter(r => r.enabled).map(r => r.id), [model.ranks]);
  const evPursesForKeep = (keepIds) => {
    const set = new Set(keepIds);
    let s = 0;
    for (const x of perRankAll) {
      if (!set.has(x.r.id)) continue;
      const prob = 1 - Math.pow(1 - x.p, model.totalTickets);
      s += (x.r.purseUsd * prob) / model.totalTickets;
    }
    return s;
  };
  const scenarioDefs = [
    { label: 'Tous les rangs', exclude: [] },
    { label: 'Sans 5+1', exclude: ['5+1'] },
    { label: 'Sans 5+1 & 5+0', exclude: ['5+1','5+0'] },
    { label: 'Sans 5+1..4+0', exclude: ['5+1','5+0','4+1','4+0'] },
  ];
  const scenarioRows = useMemo(() => {
    const rows = scenarioDefs.map(d => {
      const keep = baseKeepIds.filter(id => !d.exclude.includes(id));
      const evP = evPursesForKeep(keep);
      const myPurses = myTickets * evP;
      return { ...d, myPurses };
    });
    return rows;
  }, [scenarioDefs, baseKeepIds, perRankAll, model.totalTickets, myTickets]);
  const baselinePurses = scenarioRows[0]?.myPurses ?? 0;

  const totalPurse = useMemo(() => model.ranks.filter(r => r.enabled).reduce((s, r) => s + r.purseUsd, 0), [model]);
  const anyWinProb = useMemo(() => perRank.reduce((s, x) => s + x.p, 0), [perRank]);

  function updateModel(patch) { setModel(m => ({ ...m, ...patch })); }

  function addRank() {
    const k = model.ranks.length;
    const newRank = { id: `custom-${k+1}`, name: `Custom ${k+1}`, mainMode: "exact", mainExact: 2, bonusMode: "exact", bonusExact: 0, purseUsd: 1000, enabled: true };
    updateModel({ ranks: [...model.ranks, newRank] });
  }

  function removeRank(idx) {
    const arr = [...model.ranks];
    arr.splice(idx, 1);
    updateModel({ ranks: arr });
  }

  function updateRank(idx, newRank) {
    const arr = [...model.ranks];
    arr[idx] = newRank;
    updateModel({ ranks: arr });
  }

  // === Presets to quickly include/exclude prize ranks ===
  function setRanksEnabledByIds(keepIds) {
    const set = new Set(keepIds);
    updateModel({ ranks: model.ranks.map(r => ({ ...r, enabled: set.has(r.id) })) });
  }
  function applyPreset(code) {
    const allIds = model.ranks.map(r => r.id);
    const exclude = (ids) => allIds.filter(id => !ids.includes(id));
    let keep;
    switch (code) {
      case 'ALL':
        keep = allIds; break;
      case 'NO_TOP1':
        keep = exclude(['5+1']); break;
      case 'NO_TOP2':
        keep = exclude(['5+1','5+0']); break;
      case 'NO_TOP4':
        keep = exclude(['5+1','5+0','4+1','4+0']); break;
      case 'BOTTOM3':
        // Keep only lower three standard ranks if present; keep custom ranks too? here only the three.
        keep = allIds.filter(id => ['3+1','3+0','2+1'].includes(id));
        break;
      default:
        keep = allIds;
    }
    setRanksEnabledByIds(keep);
  }

  function exportConfig() {
    const blob = new Blob([JSON.stringify(model, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = "lottery-ev-config.json"; a.click();
    URL.revokeObjectURL(url);
  }

  function importConfig(e) {
    const file = e.target.files?.[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      try { const obj = JSON.parse(String(reader.result)); setModel(obj); } catch (err) { alert("Invalid JSON"); }
    };
    reader.readAsText(file);
  }

  const airdropUsd = (model.weeklyAirdrop?.tokenAmount || 0) * (model.weeklyAirdrop?.tokenUsdPrice || 0);

  // --- Monte Carlo simulation of ROI thresholds ---
  const roiThresholds = [-0.05, -0.10, -0.20, -0.30, -0.50, 0]; // -5%, -10%, ...
  function runSimulation() {
    try {
      setSimRunning(true);
      const N = model.totalTickets;
      const X = myTickets;
      const pList    = perRank.map(x => x.p);
      const purseUsd = perRank.map(x => x.r.purseUsd);
      const trials   = Math.max(1, Math.floor(simTrials));
      const price    = derivedModel.ticketPrice;
      const dropPT   = evAirdropPerTicket;

      const counts = Object.fromEntries(roiThresholds.map(th => [th, 0]));
      for (let t = 0; t < trials; t++) {
        let remainingN = N, remainingX = X, remP = 1.0, payout = 0;
        for (let i = 0; i < pList.length; i++) {
          const pr = pList[i];
          const adjusted = remP > 0 ? (pr / remP) : 0;           // multinomiale s√©quentielle
          const wTot = binomialSample(remainingN, adjusted);     // gagnants totaux √† ce rang
          const wMe  = hypergeomSample(remainingN, wTot, remainingX); // parmi MES X
          remainingN -= wTot; remainingX -= wMe; remP -= pr;
          if (wTot > 0 && wMe > 0) payout += wMe * (purseUsd[i] / wTot); // partage pari-mutuel
        }
        payout += X * dropPT;                      // airdrop
        const cost = X * price;
        const roi  = (payout - cost) / cost;       // ex: -0.05 = -5%
        for (const th of roiThresholds) if (roi <= th) counts[th]++;
      }
      const probs = Object.fromEntries(roiThresholds.map(th => [th, counts[th] / trials]));
      setSimResults({ trials, probs });
    } finally { setSimRunning(false); }
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-950 via-slate-900 to-slate-950 text-slate-100 p-6">
      <div className="max-w-7xl mx-auto space-y-6">
        <header className="flex items-center justify-between">
          <h1 className="text-2xl font-semibold">üéØ Lottery EV Calculator</h1>
          <div className="flex gap-2">
            <label className="text-sm px-3 py-2 rounded-xl bg-slate-900 border border-slate-700 cursor-pointer">Import config JSON
              <input type="file" className="hidden" accept="application/json" onChange={importConfig} />
            </label>
            <button className="text-sm px-3 py-2 rounded-xl bg-slate-900 border border-slate-700" onClick={exportConfig}>Export config</button>
          </div>
        </header>

        {/* Tabs */}
        <div className="flex gap-2 mb-2">
          {[
            { id: 'PARAM', label: 'Param√©trage' },
            { id: 'STATS', label: 'Stats' },
            { id: 'SIM',   label: 'Simulation' },
          ].map(t => (
            <button
              key={t.id}
              onClick={() => setTab(t.id)}
              className={`px-3 py-2 rounded-xl border ${tab===t.id ? 'bg-emerald-600/20 border-emerald-500' : 'bg-slate-900 border-slate-700'}`}
            >
              {t.label}
            </button>
          ))}
        </div>

        {tab==='PARAM' && (
          <>
        {/* Top controls */}
        <div className="grid md:grid-cols-3 gap-4">
          <div className="p-4 rounded-2xl bg-slate-900/70 border border-slate-800 space-y-3">
            <h2 className="text-lg font-medium">üéüÔ∏è Ticket & volumes</h2>
            <div className="space-y-3">
              <div className="flex items-center gap-2 text-sm">
                <button className={`px-2 py-1 rounded-lg border ${priceMode==='USD' ? 'bg-emerald-600/20 border-emerald-500' : 'bg-slate-800 border-slate-700'}`} onClick={()=>setPriceMode('USD')}>USD</button>
                <button className={`px-2 py-1 rounded-lg border ${priceMode==='BNB' ? 'bg-emerald-600/20 border-emerald-500' : 'bg-slate-800 border-slate-700'}`} onClick={()=>setPriceMode('BNB')}>BNB</button>
              </div>
              {priceMode === 'USD' ? (
                <NumberInput label="Ticket price ($)" value={model.ticketPrice} onChange={(v) => updateModel({ ticketPrice: Math.max(0, v) })} step={0.0000001} />
              ) : (
                <div className="grid grid-cols-2 gap-3">
                  <NumberInput label="Ticket price (BNB)" value={ticketPriceBNB} onChange={(v)=>setTicketPriceBNB(Math.max(0, v))} step={0.0000001} />
                  <NumberInput label="BNB price ($)" value={bnbUsd} onChange={(v)=>setBnbUsd(Math.max(0, v))} step={0.01} />
                  <div className="col-span-2 text-xs text-slate-400">Prix effectif du ticket ‚âà ${fmt(ticketPriceBNB * bnbUsd, 6)}</div>
                </div>
              )}
              <NumberInput label="Total tickets (N)" value={model.totalTickets} onChange={(v) => updateModel({ totalTickets: Math.max(1, Math.floor(v)) })} />
              <div className="text-xs text-slate-400">Mise totale ‚âà ${fmt(model.totalTickets * effectiveTicketPrice)}</div>
            </div>
          </div>

          <div className="p-4 rounded-2xl bg-slate-900/70 border border-slate-800 space-y-3">
            <h2 className="text-lg font-medium">üî¢ Draw structure</h2>
            <div className="space-y-3">
              <div className="flex items-center gap-2 text-xs">
                <span className="px-2 py-1 rounded-lg bg-slate-800/70 border border-slate-700">Main pool: 1‚Äì50 (fixe)</span>
                <span className="px-2 py-1 rounded-lg bg-slate-800/70 border border-slate-700">Bonus pool: 1‚Äì9 (fixe)</span>
              </div>
              <div className="grid grid-cols-2 gap-3">
                <NumberInput label="Main draw count (k)" value={model.main.drawCount} onChange={(v) => updateModel({ main: { ...model.main, drawCount: Math.max(0, Math.floor(v)) } })} />
                <NumberInput label="Bonus draw count (B)" value={model.bonus.drawCount} onChange={(v) => updateModel({ bonus: { ...model.bonus, drawCount: Math.max(0, Math.floor(v)) } })} />
              </div>
            </div>
            <p className="text-xs text-slate-400">Probas calcul√©es avec hyperg√©om√©trique (tirage sans remise) pour les deux urnes. Les tailles d'urnes sont <b>fixes</b> : 1‚Äì50 (main) et 1‚Äì9 (bonus).</p>
          </div>

          <div className="p-4 rounded-2xl bg-slate-900/70 border border-slate-800 space-y-3">
            <div className="flex items-center justify-between">
              <h2 className="text-lg font-medium">üéÅ Weekly airdrop</h2>
              <Switch label="Enable" checked={model.weeklyAirdrop.enabled}
                onChange={(c) => updateModel({ weeklyAirdrop: { ...model.weeklyAirdrop, enabled: c } })} />
            </div>
            <div className="grid grid-cols-3 gap-3">
              <NumberInput label="Tokens" value={model.weeklyAirdrop.tokenAmount} onChange={(v) => updateModel({ weeklyAirdrop: { ...model.weeklyAirdrop, tokenAmount: Math.max(0, v) } })} />
              <NumberInput label="Token price ($)" step={0.0001} value={model.weeklyAirdrop.tokenUsdPrice} onChange={(v) => updateModel({ weeklyAirdrop: { ...model.weeklyAirdrop, tokenUsdPrice: Math.max(0, v) } })} />
              <NumberInput label="Weekly tickets (denom)" value={model.weeklyAirdrop.weeklyTickets} onChange={(v) => updateModel({ weeklyAirdrop: { ...model.weeklyAirdrop, weeklyTickets: Math.max(1, Math.floor(v)) } })} />
            </div>
            <div className="text-xs text-slate-400">Airdrop USD ‚âà ${fmt(airdropUsd)} ‚Üí +${fmt((model.weeklyAirdrop.enabled ? airdropUsd / Math.max(1, model.weeklyAirdrop.weeklyTickets) : 0), 6)} / ticket</div>
          </div>
        </div>

        {/* Data Feeds (Fetch) */}
        <section className="p-4 rounded-2xl bg-slate-900/70 border border-slate-800 space-y-4">
          <h2 className="text-lg font-medium">üì° Data Feeds (Fetch)</h2>
          <p className="text-xs text-slate-400">Renseigne une URL JSON + un <i>dot path</i> (ex: <code>data.price</code>) pour mettre √† jour automatiquement les variables cl√©s. Id√©al pour brancher des pricefeeds / endpoints maison.</p>
          <div className="grid md:grid-cols-2 gap-4">
            <div className="p-3 rounded-xl bg-slate-900 border border-slate-800 space-y-2">
              <div className="text-sm font-medium">BNB/USD</div>
              <TextInput label="URL JSON" value={feed.bnb.url} onChange={(v)=>updateFeedField('bnb',{url:v})} placeholder="https://..." />
              <TextInput label="Chemin (dot path)" value={feed.bnb.path} onChange={(v)=>updateFeedField('bnb',{path:v})} placeholder="ex: data.price" />
              <div className="flex items-center gap-2">
                <button className="px-3 py-2 rounded-xl bg-sky-700/60 hover:bg-sky-700 border border-sky-600" onClick={()=>fetchApplyNumber('bnb', setBnbUsd)}>Fetch & Apply</button>
                <div className="text-xs text-slate-400">Dernier: {feed.bnb.last ?? '‚Äì'} {feed.bnb.error && <span className="text-rose-400">‚Ä¢ {String(feed.bnb.error)}</span>}</div>
              </div>
            </div>

            <div className="p-3 rounded-xl bg-slate-900 border border-slate-800 space-y-2">
              <div className="text-sm font-medium">LUCKY/USD</div>
              <TextInput label="URL JSON" value={feed.lucky.url} onChange={(v)=>updateFeedField('lucky',{url:v})} placeholder="https://..." />
              <TextInput label="Chemin (dot path)" value={feed.lucky.path} onChange={(v)=>updateFeedField('lucky',{path:v})} placeholder="ex: data.price" />
              <div className="flex items-center gap-2">
                <button className="px-3 py-2 rounded-xl bg-sky-700/60 hover:bg-sky-700 border border-sky-600" onClick={()=>fetchApplyNumber('lucky', (val)=>updateModel({ weeklyAirdrop: { ...model.weeklyAirdrop, tokenUsdPrice: val } }))}>Fetch & Apply</button>
                <div className="text-xs text-slate-400">Dernier: {feed.lucky.last ?? '‚Äì'} {feed.lucky.error && <span className="text-rose-400">‚Ä¢ {String(feed.lucky.error)}</span>}</div>
              </div>
            </div>

            <div className="p-3 rounded-xl bg-slate-900 border border-slate-800 space-y-2">
              <div className="text-sm font-medium">LUCKY tokens / semaine</div>
              <TextInput label="URL JSON" value={feed.tokens.url} onChange={(v)=>updateFeedField('tokens',{url:v})} placeholder="https://..." />
              <TextInput label="Chemin (dot path)" value={feed.tokens.path} onChange={(v)=>updateFeedField('tokens',{path:v})} placeholder="ex: data.amount" />
              <div className="flex items-center gap-2">
                <button className="px-3 py-2 rounded-xl bg-sky-700/60 hover:bg-sky-700 border border-sky-600" onClick={()=>fetchApplyNumber('tokens', (val)=>updateModel({ weeklyAirdrop: { ...model.weeklyAirdrop, tokenAmount: Math.max(0, val) } }))}>Fetch & Apply</button>
                <div className="text-xs text-slate-400">Dernier: {feed.tokens.last ?? '‚Äì'} {feed.tokens.error && <span className="text-rose-400">‚Ä¢ {String(feed.tokens.error)}</span>}</div>
              </div>
            </div>

            <div className="p-3 rounded-xl bg-slate-900 border border-slate-800 space-y-2">
              <div className="text-sm font-medium">Tickets semaine (denom airdrop)</div>
              <TextInput label="URL JSON" value={feed.weekly.url} onChange={(v)=>updateFeedField('weekly',{url:v})} placeholder="https://..." />
              <TextInput label="Chemin (dot path)" value={feed.weekly.path} onChange={(v)=>updateFeedField('weekly',{path:v})} placeholder="ex: data.count" />
              <div className="flex items-center gap-2">
                <button className="px-3 py-2 rounded-xl bg-sky-700/60 hover:bg-sky-700 border border-sky-600" onClick={()=>fetchApplyNumber('weekly', (val)=>updateModel({ weeklyAirdrop: { ...model.weeklyAirdrop, weeklyTickets: Math.max(1, Math.floor(val)) } }))}>Fetch & Apply</button>
                <div className="text-xs text-slate-400">Dernier: {feed.weekly.last ?? '‚Äì'} {feed.weekly.error && <span className="text-rose-400">‚Ä¢ {String(feed.weekly.error)}</span>}</div>
              </div>
            </div>
          </div>

          <div className="p-3 rounded-xl bg-slate-900 border border-slate-800 space-y-2">
            <div className="text-sm font-medium">Charger un mod√®le complet (JSON)</div>
            <TextInput label="URL du model.json" value={feed.model.url} onChange={(v)=>setFeed(f=>({...f, model:{...f.model, url:v}}))} placeholder="https://.../state.json" />
            <button className="px-3 py-2 rounded-xl bg-emerald-700/60 hover:bg-emerald-700 border border-emerald-600" onClick={loadModelFromUrl}>Load model from URL</button>
            <div className="text-xs text-slate-400">Le mod√®le doit suivre la structure affich√©e dans l'export JSON (ticketPrice/totalTickets/main/bonus/weeklyAirdrop/ranks...).</div>
          </div>
        </section>

        {/* Ranks editor */}
        <section className="space-y-3">
          <div className="flex items-center justify-between">
            <h2 className="text-lg font-medium">üèÜ Prize ranks</h2>
            <div className="flex items-center gap-2 flex-wrap">
              <button className="px-2 py-1 rounded-lg bg-slate-800 border border-slate-700 hover:bg-slate-700" onClick={() => applyPreset('ALL')}>Tous</button>
              <button className="px-2 py-1 rounded-lg bg-slate-800 border border-slate-700 hover:bg-slate-700" onClick={() => applyPreset('NO_TOP1')}>Sans 5+1</button>
              <button className="px-2 py-1 rounded-lg bg-slate-800 border border-slate-700 hover:bg-slate-700" onClick={() => applyPreset('NO_TOP2')}>Sans 5+1 & 5+0</button>
              <button className="px-2 py-1 rounded-lg bg-slate-800 border border-slate-700 hover:bg-slate-700" onClick={() => applyPreset('NO_TOP4')}>Sans 5+1..4+0</button>
              <button className="px-2 py-1 rounded-lg bg-slate-800 border border-slate-700 hover:bg-slate-700" onClick={() => applyPreset('BOTTOM3')}>3+1, 3+0, 2+1</button>
              <button className="px-3 py-2 rounded-xl bg-slate-900 border border-slate-700" onClick={addRank}>+ Add rank</button>
            </div>
          </div>
          <div className="space-y-2">
            {model.ranks.map((r, i) => (
              <RankRow key={r.id} r={r} mMain={model.main.drawCount} mBonus={model.bonus.drawCount}
                onChange={(nr) => updateRank(i, nr)} onRemove={() => removeRank(i)} />
            ))}
          </div>
          <div className="text-xs text-slate-400">Purse = cagnotte fixe √† partager (pari-mutuel). D√©coche un rang pour l'exclure.
          </div>
        </section>
          </>
        )}

        {/* Results */}
        {tab==='STATS' && (
          <>
        <section className="grid lg:grid-cols-5 gap-4">
          <div className="p-4 rounded-2xl bg-slate-900/70 border border-slate-800 space-y-2">
            <h3 className="font-medium">üìä EV & ROI</h3>
            <div className="text-sm">Prizepool actif (somme des rangs coch√©s): <b>${fmt(totalPurse)}</b></div>
            <div className="text-sm">EV (purses) / ticket: <b>${fmt(evPurses, 6)}</b></div>
            <div className="text-sm">EV (airdrop) / ticket: <b>${fmt(evAirdropPerTicket, 6)}</b></div>
            <div className="text-sm">EV totale / ticket: <b>${fmt(evPerTicket, 6)}</b></div>
            <div className="text-sm">EV nette / ticket: <b>${fmt(evNetPerTicket, 6)}</b></div>
            <div className="text-sm">ROI (= EV / prix): <b>{fmt(roi, 4)}√ó</b></div>
          </div>
          <div className="p-4 rounded-2xl bg-slate-900/70 border border-slate-800 space-y-2">
            <h3 className="font-medium">‚öñÔ∏è Break-even (EV = prix)</h3>
            <div className="text-sm">Seuil tickets (hors airdrop): <b>{nStarNoAirdrop ? fmt0(nStarNoAirdrop) : ">5 000 000"}</b></div>
            <div className="text-sm">Seuil tickets (avec airdrop): <b>{nStarWithAirdrop ? fmt0(nStarWithAirdrop) : ">5 000 000"}</b></div>
            <div className="text-xs text-slate-400">Si la valeur du token/volume airdrop varie, ce seuil √©volue.</div>
          </div>
          <div className="p-4 rounded-2xl bg-slate-900/70 border border-slate-800 space-y-2">
            <h3 className="font-medium">üéØ Probas par ticket</h3>
            <div className="text-xs text-slate-400">P(au moins un prix) = somme des probas exactes des rangs actifs.</div>
            <div className="text-sm">P(‚â• 1 prix) ‚âà <b>{fmt(anyWinProb * 100, 6)}%</b></div>
          </div>

          <div className="p-4 rounded-2xl bg-slate-900/70 border border-slate-800 space-y-2">
            <h3 className="font-medium">üéØ EV0 par composant</h3>
            <div className="text-sm">Tirage seul (N*) : <b>{nStarNoAirdrop ? fmt0(nStarNoAirdrop) : ">5 000 000"}</b></div>
            <div className="text-sm">Airdrop seul (weeklyTickets*) : <b>{airdropBreakEvenWeeklyTickets ? fmt0(airdropBreakEvenWeeklyTickets) : '‚Äì'}</b></div>
            <div className="text-xs text-slate-400">Actuel weeklyTickets : {fmt0(model.weeklyAirdrop?.weeklyTickets || 0)} ‚Ä¢ L'airdrop couvre ~{fmt(airdropCoverage*100, 2)}% du prix ticket.</div>
          </div>

          {/* Monte Carlo simulation card */}
          <div className="p-4 rounded-2xl bg-slate-900/70 border border-slate-800 space-y-2">
            <h3 className="font-medium">üé≤ Odds vs ROI thresholds</h3>
            <div className="grid grid-cols-2 gap-3">
              <NumberInput label="Trials (Monte Carlo)" value={simTrials}
                onChange={(v)=>setSimTrials(Math.max(100, Math.floor(v)))} />
              <div className="flex items-end">
                <button className="px-3 py-2 rounded-xl bg-sky-700/60 hover:bg-sky-700 border border-sky-600 disabled:opacity-50"
                        disabled={simRunning} onClick={runSimulation}>
                  {simRunning ? 'Running‚Ä¶' : 'Run simulation'}
                </button>
              </div>
            </div>

            {simResults ? (
              <div className="overflow-x-auto">
                <table className="w-full text-sm">
                  <thead>
                    <tr className="text-slate-300 border-b border-slate-800">
                      <th className="text-left py-1">Seuil (ROI)</th>
                      <th className="text-right py-1">P(ROI ‚â§ seuil)</th>
                    </tr>
                  </thead>
                  <tbody>
                    {roiThresholds.map(th => (
                      <tr key={th} className="border-b border-slate-800/60">
                        <td className="py-1">{Math.round(th*100)}%</td>
                        <td className="py-1 text-right">{fmt((simResults.probs[th] || 0) * 100, 2)}%</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
                <div className="text-xs text-slate-400 mt-1">
                  Bas√© sur {fmt0(simResults.trials)} essais; inclut airdrop et partage pari-mutuel.
                </div>
              </div>
            ) : (
              <div className="text-xs text-slate-400">
                Clique ¬´ Run simulation ¬ª pour estimer les probabilit√©s d'atterrir sous ‚àí5%, ‚àí10%, ‚àí20%, etc.
              </div>
            )}
          </div>
        </section>

        {/* Per-rank table */}
        <section className="p-4 rounded-2xl bg-slate-900/70 border border-slate-800">
          <h3 className="font-medium mb-3">üìà D√©tails par rang (avec N = {fmt0(model.totalTickets)})</h3>
          <div className="overflow-x-auto">
            <table className="w-full text-sm">
              <thead>
                <tr className="text-slate-300 border-b border-slate-800">
                  <th className="text-left py-2">Rang</th>
                  <th className="text-right py-2">P(exacte)</th>
                  <th className="text-right py-2">E[# gagnants]</th>
                  <th className="text-right py-2">P(‚â•1 gagnant)</th>
                  <th className="text-right py-2">Purse ($)</th>
                  <th className="text-right py-2">Contrib. EV/ticket ($)</th>
                </tr>
              </thead>
              <tbody>
                {perRank.map(({ r, p, expectedWinners, probAtLeastOneWinner, contributionPerTicket }) => (
                  <tr key={r.id} className="border-b border-slate-800/60">
                    <td className="py-2 text-slate-200">{r.name}</td>
                    <td className="py-2 text-right">{fmt(p * 100, 6)}%</td>
                    <td className="py-2 text-right">{fmt(expectedWinners, 4)}</td>
                    <td className="py-2 text-right">{fmt(probAtLeastOneWinner * 100, 4)}%</td>
                    <td className="py-2 text-right">${fmt(r.purseUsd)}</td>
                    <td className="py-2 text-right">${fmt(contributionPerTicket, 6)}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </section>

        {/* Utility notes */}
        <section className="text-xs text-slate-400 space-y-1">
          <p>üîå <b>Live updates</b>: branche un fetch vers tes endpoints (prizepool, ventes, prix du $LUCKY). Par ex. programme un cron/serverless qui alimente un JSON public, puis charge-le ici pour mettre √† jour le mod√®le.</p>
          <p>üß© <b>Types de tirage</b> : ajuste uniquement le <i>nombre de tirages</i> (k pour les principaux, B pour le bonus) et configure les rangs (exact/range). Les <b>tailles d'urnes sont fixes</b> : 1‚Äì50 (main) et 1‚Äì9 (bonus).</p>
          <p>üßÆ <b>Formules</b>: Hyperg√©om√©trique pour chaque urne; ind√©pendance entre urnes; EV pari-mutuel √† cagnotte fixe partag√©e.</p>
        </section>
          </>
        )}

        {/* Simulation */}
        {tab==='SIM' && (
          <section className="grid lg:grid-cols-2 gap-4">
            <div className="p-4 rounded-2xl bg-slate-900/70 border border-slate-800 space-y-2">
              <h3 className="font-medium">üßÆ Mes tickets</h3>
              <NumberInput label="Nombre de tickets" value={myTickets} onChange={(v)=>setMyTickets(Math.max(0, Math.floor(v)))} />
              <div className="text-sm">Si j'ach√®te <b>{fmt0(myTickets)}</b> tickets&nbsp;:</div>
              <div className="text-sm">‚Äî au tirage (purses) ‚âà <b>${fmt(myTickets * evPurses, 2)}</b></div>
              <div className="text-sm">‚Äî d'airdrop ‚âà <b>${fmt(myTickets * evAirdropPerTicket, 2)}</b></div>
              <div className="text-sm">Total EV ‚âà <b>${fmt(myTickets * (evPurses + evAirdropPerTicket), 2)}</b> ‚Ä¢ Co√ªt ‚âà <b>${fmt(myTickets * derivedModel.ticketPrice, 2)}</b></div>
              <div className="text-sm">
                EV nette ‚âà <b>${fmt(myTickets * (evPurses + evAirdropPerTicket - derivedModel.ticketPrice), 2)}</b> ‚Ä¢
                ROI ‚âà <b>{((evPurses + evAirdropPerTicket) / derivedModel.ticketPrice).toFixed(3)}√ó</b>
              </div>
            </div>

            <div className="p-4 rounded-2xl bg-slate-900/70 border border-slate-800 space-y-2">
              <h3 className="font-medium">üìä Sc√©narios d'exclusion</h3>
              <div className="overflow-x-auto">
                <table className="w-full text-sm">
                  <thead>
                    <tr className="text-slate-300 border-b border-slate-800">
                      <th className="text-left py-1">Sc√©nario</th>
                      <th className="text-right py-1">Au tirage ($)</th>
                      <th className="text-right py-1">Œî vs Tous</th>
                      <th className="text-right py-1">Airdrop ($)</th>
                    </tr>
                  </thead>
                  <tbody>
                    {scenarioRows.map((row) => (
                      <tr key={row.label} className="border-b border-slate-800/60">
                        <td className="py-1">{row.label}</td>
                        <td className="py-1 text-right">${fmt(row.myPurses, 2)}</td>
                        <td className="py-1 text-right">{(scenarioRows[0]?.myPurses ?? 0) > 0 ? `${fmt(((row.myPurses / scenarioRows[0].myPurses) - 1) * 100, 2)}%` : '‚Äì'}</td>
                        <td className="py-1 text-right">${fmt(myTickets * evAirdropPerTicket, 2)}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>
          </section>
        )}
      </div>
    </div>
  );
}

    ReactDOM.render(<LotteryEVApp />, document.getElementById('root'));
  </script>
</body>
</html>